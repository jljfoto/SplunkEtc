{"version":3,"sources":["webpack:///./~/SplunkWebCore/search_mrsparkle/exposed/js/splunkjs/mvc/debugger.js","webpack:///./~/SplunkWebCore/search_mrsparkle/exposed/js/splunkjs/mvc/basesplunkview.js","webpack:///./~/SplunkWebCore/search_mrsparkle/exposed/js/splunkjs/mvc/settings.js","webpack:///./~/SplunkWebCore/search_mrsparkle/exposed/js/mixins/viewlogging.js"],"names":[],"mappings":";;;;;mCAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,WAAW,O;AAClC,2B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iC;AACA,6B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kD;AACA,cAAa;;AAEb;AACA;AACA,iDAAgD,kCAAkC;AAClF,8CAA6C,+BAA+B;AAC5E,mDAAkD,oCAAoC;;AAEtF;AACA;AACA;AACA,2DAA0D,wBAAwB;;AAElF;AACA,kD;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kH;AACA,kCAAiC;AACjC;AACA,0BAAyB;AACzB,sBAAqB;;AAErB;AACA;AACA,kBAAiB;AACjB,cAAa;;AAEb;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,kB;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET,yC;AACA;AACA,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4G;AACA;AACA,0G;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qF;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gH;AACA;AACA,iG;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kB;AACA,cAAa;AACb,UAAS;;AAET;AACA;AACA;AACA,6CAA4C,gCAAgC;AAC5E;AACA;AACA,UAAS;;AAET,sC;AACA,uD;AACA,UAAS;;AAET,yC;AACA,0D;AACA,UAAS;;AAET,2C;AACA,4D;AACA,UAAS;;AAET,4B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL;AACA,EAAC;;;;;;;;mCC3ZD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ,oCAAoC;AAC5C;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO,+BAA+B,OAAO;AAC5D;AACA,gBAAe,OAAO;AACtB;AACA,gBAAe,OAAO;AACtB;AACA,gBAAe,OAAO;AACtB;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA4D,mCAAmC;;AAE/F;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,yCAAyC;AACnF;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,4CAA2C,GAAG;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE;AACA,kBAAiB;AACjB;;AAEA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA,4CAA2C,GAAG;AAC9C;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA,eAAc,QAAQ;AACtB,eAAc,QAAQ;AACtB;;;;;;;;mCC9OA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,cAAc;AACxC,MAAK;;AAEL;AACA,EAAC;;;;;;;;;ACfD;AACA;AACA;AACA;AACA;AACA,4CACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;;AAEA;;AAEA,EAAC,gJ","file":"3.3.js","sourcesContent":["define(function(require, exports, module) {\n    var _ = require(\"underscore\");\n    var Backbone = require(\"backbone\");\n    var BaseManager = require('./basemanager');\n    var BaseSplunkView = require('./basesplunkview');\n    var BaseTokenModel = require('./basetokenmodel');\n    var SearchModels = require('./searchmodel');\n    var console = window.console;\n\n    var indent = function(count) {\n        var str = '';\n        for (var i = 0; i < count; i++) { \n            str += '    '; \n        }\n        return str;\n    };\n\n    var warn = function(msg) {\n        return (\"WARNING: \" + msg);\n    };\n\n    var categoryEnum = {\n        MANAGER: 'manager',\n        VIEW: 'view',\n        NAMESPACE: 'namespace',\n        UNKNOWN: 'unknown'\n    };\n\n    var Debugger = Backbone.Model.extend(/** @lends splunkjs.mvc.Debugger.prototype */{\n        ready : false,\n\n        initialize: function() { \n            var that = this;    \n\n            that.registry = that.get('registry');\n\n            if (!that.registry) {\n                console.log(\"splunk.mvc debugging interface could not find the registry\");\n                return;\n            }\n\n            // For now this is a command-line tool, so we put information on the command line.\n            console.log(\"The Splunkjs debugger is running. For help, enter 'splunkjs.mvc.Debugger.help()'\");\n        },\n\n        isReady: function() {\n            return this.ready;\n        },\n\n        getDebugData: function() {\n\n            var that = this;\n            var components = [];\n\n            var registeredComponentKeys = that.registry.getInstanceNames();\n\n            _.each(registeredComponentKeys, function(elementID) {\n                var registryElement = that.registry.getInstance(elementID);\n                var type = that._getComponentType(registryElement);\n                var category = that._getComponentCategory(registryElement);\n                var validOptions = [];\n                \n                var elementMetaData = { \n                    'id' : elementID,\n                    'category' : category,\n                    'type': type,\n                    'warnings': []\n                };\n\n                // Add data to views\n                if (category === categoryEnum.VIEW) {\n                    var managerid = null;\n                    var settings = {};\n                    validOptions = that._getValidViewOptions(registryElement);\n\n                    // If the view has settings we inspect them for issues\n                    // JIRA: DVPL-3316\n                    if (registryElement.settings) {\n                        managerid = registryElement.settings.get('managerid') || null;\n                        settings = _.clone(registryElement.settings.attributes);\n                        \n                        _.each(_.keys(settings), function(key) {\n\n                            // If a setting is not known to be valid we add a warning\n                            if (!_.contains(validOptions, key)) {\n\n                                // Ignore unrecognized map and chart settings\n                                // JIRA: DVPL-3317\n                                var partOne = key.split('.')[0];\n                                if (!(partOne === 'mapping' || partOne === 'charting')) {\n                                    elementMetaData.warnings.push(warn(key + \" is not a recognized setting.\"));\n                                }\n                            }\n                        });\n                    }\n                    \n                    elementMetaData.managerid = managerid;\n                    elementMetaData.settings = settings;\n                    elementMetaData.el = registryElement.el || \"no element set\";\n                }\n                // Add data to token namespaces\n                if (category === categoryEnum.NAMESPACE) {\n                    elementMetaData.tokens = [];\n\n                    // For each token in the namespace, attach the value and an empty list of \n                    // listeners that will be populated later \n                    _.each(registryElement.attributes, function(value, key) {\n                        var tokenData = {\n                            name: key,\n                            value : value,\n                            listenerIds: []\n                        };\n                        elementMetaData.tokens.push(tokenData);\n                    });\n                }    \n                // Add data to managers\n                if (category === categoryEnum.MANAGER) {\n                    validOptions = that._getValidManagerOptions(registryElement);\n                    \n                    if (registryElement.attributes) {\n                        var attributes = _.clone(registryElement.attributes);\n                        \n                        _.each(_.keys(attributes), function(key) {\n                            // If a setting is not known to be valid we add a warning\n                            if (!_.contains(validOptions, key)) {\n                                elementMetaData.warnings.push(warn(key + \" is not a recognized attribute\"));\n                            }\n                        });\n                    }\n                    \n                    elementMetaData.attributes = registryElement.attributes;\n                    elementMetaData.query = registryElement.query;\n                    elementMetaData.search = registryElement.search;\n                }\n\n                // Add token data to everything but namespaces\n                if (category !== categoryEnum.NAMESPACE) {\n                    elementMetaData.bindings = that._getComponentBindings(elementID);\n                }\n                components.push(elementMetaData);                \n            });\n                \n            // Now that we have our elements in place, we can check connections between them\n            // and look for other potential issues. First, separate componenet types for convenience.\n            var managers = _.where(components, {'category' : categoryEnum.MANAGER});\n            var views = _.where(components, {'category' : categoryEnum.VIEW});\n            var namespaces = _.where(components, {'category' : categoryEnum.NAMESPACE});\n            \n            // Enumerate views bound to each manager and check for issues\n            _.each(managers, function(manager) {\n                // Pluck the view ids from views where managerid is this manager's id\n                manager.viewIds = _.pluck(_.where(views, {'managerid': manager.id}), 'id');\n\n                // If there are no views bound to the search, push a warning\n                if (manager.viewIds.length < 1) { \n                    manager.warnings.push(warn(\"no views bound to search manager.\"));\n                }\n            });\n\n            // Check for views bound to non-existent managers\n            _.each(views, function(view) {\n                if (view.managerid) {\n                    if (!_.contains(_.pluck(managers, 'id'), view.managerid)) {\n                        view.warnings.push(warn(view.managerid + \" is not a registered manager.\"));\n                    }\n                }\n            });\n\n            // Find components bound to each token and attach them to token metadata\n            _.each(namespaces, function(namespace) {\n                _.each(namespace.tokens, function(token) {\n                    // Look through views and managers and find those that watch this\n                    // token's name\n                    var listeners = _.filter(_.union(managers, views), function(item) {\n                        return _.some(item.bindings, function(binding) {\n                            if (binding && binding.observes && binding.observes.length > 0) {\n                                return _.some(binding.observes, function(observes) {\n                                    return (observes.namespace === namespace.id && observes.name === token.name);        \n                                });\n                            }\n                        });\n                    });\n\n                    // Attach just the ids of the listeners\n                    token.listenerIds = _.pluck(listeners, 'id');\n                });\n            });\n\n            return components;\n        },\n\n        _getValidViewOptions: function(element) {\n            var options = ['id', 'name', 'managerid', 'manager', 'app', 'el', 'data'];\n\n            // Again we check this is valid.\n            if (element.constructor.prototype.options) {\n                options = _.union(options, _.keys(element.constructor.prototype.options));\n            }\n            return options;\n        },\n\n        _getValidManagerOptions: function(element) {\n            var validOptions = _.union(\n                ['app', 'id', 'owner', 'name', 'data'], \n                _.keys(element.constructor.prototype.defaults) || [], \n                SearchModels.SearchSettingsModel.ALLOWED_ATTRIBUTES\n            );\n            \n            return validOptions;\n        },\n\n        _getComponentType: function(component) {\n            var type = \"Unknown type\";\n            if (component.moduleId) {\n                var name = component.moduleId.split('/').pop();\n                if (name.length > 0) {\n                    type = name;\n                }                \n            }\n            return type;\n        },\n\n        _getComponentCategory: function(component) {\n            var category = categoryEnum.UNKNOWN;\n\n            if (component instanceof BaseSplunkView) {\n                category = categoryEnum.VIEW;\n            }\n            else if (component instanceof BaseManager) {\n                category = categoryEnum.MANAGER;\n            }\n            else if (component instanceof BaseTokenModel) {\n                category = categoryEnum.NAMESPACE;\n            }\n            return category;\n        },\n\n        _getComponentTokenBoundProperties: function(componentId) {\n            var tokenBoundProperties = [];\n            var bindings = this._getComponentBindings(componentId);\n            tokenBoundProperties = _.keys(bindings);\n            return tokenBoundProperties;\n        },\n\n        _getComponentBindings: function(componentId) {\n            var component = this.registry.getInstance(componentId);\n            \n            var bindings = {};\n            if (component && component.settings) {\n                bindings = _.extend(bindings, _.clone(component.settings._bindings));\n            }\n            return bindings;\n        },\n        \n        createError: function(message) {            \n            return message;\n        },\n\n        printViewInfo: function() {\n            var that = this;\n            var views = that.getInfoForViews();\n\n            console.log(\"Views:\");\n            _.each(views, function(view) {\n                console.log(indent(1) + \"ID: \" + view.id);\n                console.log(indent(2) + \"Type: \" + view.type);\n                console.log(indent(2) + \"Manager: \" + view.managerid);\n                console.log(indent(2) + \"Element: \", view.el);\n                console.log(indent(2) + \"Settings: \");\n                _.each(_.keys(view.settings), function(key) {\n                    var tokenInfo = \"\";\n                    var binding = view.bindings[key];\n                    var hasTokens = binding && binding.observes && binding.observes.length > 0;\n                    if (hasTokens) {\n                        var template = JSON.stringify(binding.template);\n                        var partiallyResolvedValue = JSON.stringify(binding.computeValue(/*_retainUnmatchedTokens=*/true));\n                        tokenInfo = \" [bound: \" + template + \", resolved: \" + partiallyResolvedValue + \"]\";    \n                    }\n                    console.log(indent(3) + key + \": \" + JSON.stringify(view.settings[key]) + tokenInfo); \n                });\n                if(view.warnings.length>0) {\n                    console.log(indent(2) + \"WARNINGS: \");\n                    _.each(view.warnings, function(warning) {\n                        console.log(indent(3) + warning);\n                    });\n                }\n            });\n        },\n\n        printSearchManagerInfo: function() {\n            var that = this;\n            var managers = that.getInfoForManagers();\n\n            console.log(\"Search Managers:\");\n            _.each(managers, function(manager) {\n                console.log(indent(1) + \"ID: \" + manager.id);\n                console.log(indent(2) + \"Type: \" + manager.type);\n                if (manager.attributes) {\n                    console.log(indent(2) + \"Attributes: \" );\n                    var propertiesToSkip = SearchModels.SearchSettingsModel.ALLOWED_ATTRIBUTES;\n                    \n                    _.each(manager.attributes, function(value, key) {\n                        if (_.contains(propertiesToSkip, key)) {\n                            return;\n                        }\n                        console.log(indent(3) + key + \": \" + JSON.stringify(value)); \n                    });\n                }\n                if (manager.settings && manager.settings.attributes) {\n                    console.log(indent(2) + \"Search Properties: \" );\n                    _.each(manager.settings.attributes, function(value, key) {\n                        var tokenInfo = \"\";\n                        var binding = manager.bindings[key];\n                        var hasTokens = binding && binding.observes && binding.observes.length > 0;\n                        if (hasTokens) {\n                            var template = JSON.stringify(binding.template);\n                            var partiallyResolvedValue = JSON.stringify(binding.computeValue(/*_retainUnmatchedTokens=*/true));\n                            tokenInfo = \" [bound: \" + template + \", resolved: \" + partiallyResolvedValue + \"]\";    \n                        }\n                        console.log(indent(3) + key + \": \" + JSON.stringify(value) + tokenInfo); \n                    });\n                }\n                console.log(indent(2) + \"Views bound to manager: \");\n                _.each(manager.viewIds, function(id) {\n                    console.log(indent(3) + id);\n                });\n                if (manager.warnings.length > 0) {\n                    console.log(indent(2) + \"WARNINGS: \");\n                    _.each(manager.warnings, function(warning) {\n                        console.log(indent(3) + warning);\n                    });\n                }\n            });\n        },\n\n        printTokenNamespaceInfo: function() {\n            var that = this;\n            var namespaces = that.getInfoForNamespaces();\n\n            console.log(\"Token Namespaces:\");\n            _.each(namespaces, function(namespace) {\n                console.log(indent(1) + \"ID: \" + namespace.id);\n                console.log(indent(2) + \"Type: \" + namespace.type);\n                console.log(indent(2) + \"Tokens: \");\n                _.each(namespace.tokens, function(token) {\n                    console.log(indent(3) + token.name + \": \");\n                    console.log(indent(4) + \"value: \" + JSON.stringify(token.value));\n                    console.log(indent(4) + \"listeners: \" + token.listenerIds.join(', '));\n                });\n            });\n        },\n\n        /**\n         * Prints all component info\n         */\n        printComponentInfo: function() {\n            this.printViewInfo();\n            this.printSearchManagerInfo();\n            this.printTokenNamespaceInfo();\n        },\n\n        printWarnings: function() {\n            var that = this;\n            var components = that.getDebugData();\n            console.log(\"WARNINGS:\");\n            _.each(components, function(item) {\n                if (item.warnings.length > 0 ) {\n                    console.log(indent(1), \"ID: \" + item.id + \": \");\n                    _.each(item.warnings, function(warning) {\n                        console.log(indent(2) + warning);\n                    });\n                }             \n            });\n        },\n\n        _getInfoForComponents: function(ctype) {\n            var components = this.getDebugData();\n            if (ctype !== undefined) {\n                return _.where(components, {'category': categoryEnum[ctype]});\n            }\n            return components;\n        },\n\n        getInfoForViews: function() { \n            return this._getInfoForComponents('VIEW'); \n        },\n\n        getInfoForManagers: function() { \n            return this._getInfoForComponents('MANAGER'); \n        },\n\n        getInfoForNamespaces: function() { \n            return this._getInfoForComponents('NAMESPACE'); \n        },\n\n        help : function() { \n            console.log(\"Splunkjs Debugger Commands\");\n            console.log(indent(1) + \"- printWarnings(): Prints all warnings to the console.\");\n            console.log(indent(1) + \"- printComponentInfo(): Prints all debug info and warnings to the console by component.\");\n            console.log(indent(1) + \"- printViewInfo(): Prints debug info for all Splunk views.\");\n            console.log(indent(1) + \"- printSearchManagerInfo(): Prints debug info for all Splunk search managers.\");\n            console.log(indent(1) + \"- printTokenNamespaceInfo(): Prints debug info for Splunk token namespaces.\");\n            console.log(indent(1) + \"- getDebugData(): Returns all debug metadata for components and namespaces.\");\n            console.log(indent(1) + \"- getInfoForViews(): Returns debug metadata for all Splunk views.\");\n            console.log(indent(1) + \"- getInfoForManagers(): Returns debug metadata for all Splunk managers.\");\n            console.log(indent(1) + \"- getInfoForNamespaces(): Returns debug metadata for all Splunk token namespaces.\");\n        }\n\n    });\n    \n    return Debugger;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/SplunkWebCore/search_mrsparkle/exposed/js/splunkjs/mvc/debugger.js\n// module id = splunkjs/mvc/debugger\n// module chunks = 3","define(function(require, exports, module) {\n    var _ = require(\"underscore\");\n    var mvc = require('./mvc');\n    var console = require('util/console');\n    var Backbone = require(\"backbone\");\n    var Settings = require(\"./settings\");\n    var viewloggingmixin = require('mixins/viewlogging');\n\n    /**\n     * @constructor\n     * @memberOf splunkjs.mvc\n     * @name BaseSplunkView\n     * @private\n     * @description The **BaseSplunkView** base view class is used for Splunk \n     * views. This class is not designed to be subclassed. Extend \n     * {@link splunkjs.mvc.SimpleSplunkView} instead.\n     * @extends splunkjs.mvc.Backbone.View\n     * @mixes viewlogging \n     * \n     * @param {Object} options \n     * @param {String} options.id - The unique ID for this control.\n     * @param {String} options.el - Pre-existing &lt;div&gt; tag in which to render\n     * this view.\n     * @param {Object} options.settings -  A **Settings** model instance to \n     * use.\n     * @param {Object} options.settingsOptions -  Initial options for this \n     * view's **Settings** model.\n     * @param {Object} options.* - Initial attributes for this view's \n     * **Settings** model. See the subclass documentation for details.\n     * @param {Object} settingsOptions - The initial options for this view's\n     * **Settings** model.\n     */\n    var BaseSplunkView = Backbone.View.extend(/** @lends splunkjs.mvc.BaseSplunkView.prototype */{\n        _numConfigureCalls: 0,\n        \n        /**\n         * @protected\n         * Names of options that will be excluded from this component's\n         * settings model if passed to the constructor.\n         */\n        omitFromSettings: [],\n        _uniqueIdPrefix: 'view_',\n\n        constructor: function(options, settingsOptions) {\n            options = options || {};\n            settingsOptions = settingsOptions || {};\n            \n            options.settingsOptions = _.extend(\n                options.settingsOptions || {},\n                settingsOptions);\n\n            // Internal property to track object lifetime. \n            // With this flag we want to prevent invoking methods / code\n            // on already removed instance.\n            this._removed = false;\n            \n            // Get an ID or generate one\n            var id = options.id;\n            if (id === undefined && options.name) {\n                id = options.name;\n                console.warn(\"Use of 'name' to specify the ID of a Splunk model is deprecated.\");\n            }\n\n            if (id === undefined) {\n                id = _.uniqueId(this._uniqueIdPrefix || 'view_');\n            }\n\n            this.name = this.id = options.name = options.id = id;\n\n            this.options = _.extend({}, this.options, options);\n\n            // Delegate to Backbone.View's constructor.\n            // NOTE: This will call initialize() as a side effect.\n            var returned = Backbone.View.prototype.constructor.apply(this, arguments);\n            if (this._numConfigureCalls == 0) {\n                // initialize() should have called configure() but did not.\n                // In this case automatically call configure().\n                this.configure();\n            }\n\n            // Register self in the global registry\n            mvc.Components.registerInstance(this.id, this, { replace: settingsOptions.replace });\n            \n            return returned;\n        },\n        \n        /**\n         * @protected\n         * Initializes this view's settings model based on the contents of\n         * `this.options`.\n         */\n        configure: function() {\n            this._numConfigureCalls++;\n            if (this._numConfigureCalls > 1) {\n                throw new Error('BaseSplunkView.configure() called multiple times.');\n            }\n            \n            // We may have received a Settings model instance to use instead\n            // of creating our own. If so, we just use it and return immediately.\n            var settings = this.options.settings;\n            if (settings && (settings instanceof Settings)) {\n                this.settings = settings;\n                return this;\n            }\n            \n            // Reinterpret remaining view options as settings attributes.\n            var localOmitFromSettings = (this.omitFromSettings || []).concat(\n                ['model', 'collection', 'el', 'attributes', \n                 'className', 'tagName', 'events', 'settingsOptions']);\n\n            var settingsAttributes = _.omit(this.options, localOmitFromSettings);\n            var settingsOptions = this.options.settingsOptions;\n\n            // Now, we create our default settings model.\n            this.settings = new Settings(settingsAttributes, settingsOptions);\n\n            return this;\n        },\n        \n        // JIRA: Just invoke configure() from constructor() instead of\n        //       relying on subclasses to do it. (Don't forget to update\n        //       the doc comment above.) (DVPL-2436)\n        /**\n         * Initializes this view.\n         * \n         * Subclasses are expected to override this method.\n         * \n         * All implementations must call {@link splunkjs.mvc.configure | configure}, usually at the beginning\n         * of this method.\n         */\n        initialize: function() {\n            Backbone.View.prototype.initialize.apply(this, arguments);\n        },\n        \n        remove: function() {\n            this._removed = true;\n\n            this.settings.dispose();\n\n            // Call our super class\n            Backbone.View.prototype.remove.apply(this, arguments);\n            \n            // Remove it from the registry\n            if (mvc.Components.getInstance(this.id) === this) {\n                mvc.Components.revokeInstance(this.id);\n            }\n            \n            return this;\n        },\n        \n        dispose: function() {\n            this.remove();\n        },\n\n        setElement: function() {\n            // We're doing this in setElement for a few reasons:\n            // 1. It means that subclasses won't have to worry about\n            // calling our initialize class.\n            // 2. It is actually the most robust way to do this, because\n            // it means we will catch both construction of new views, as \n            // well as later calls to setElement\n            \n            // Call our super class\n            Backbone.View.prototype.setElement.apply(this, arguments);\n            \n            // Now that we have our new $el, we can call addClass on it\n            this.$el.addClass(\"splunk-view\");\n            if (this.className) {\n                this.$el.addClass(this.className);\n            }\n            \n            if (!this.$el.attr('id')) {\n                this.$el.attr('id', this.id);\n            }\n            \n            return this;\n        },\n        \n        bindToComponentSetting: function(settingName, fn, fnContext) {\n            this.listenTo(this.settings, \"change:\" + settingName, function(model, value, options) {\n                var oldComponentName = this.settings.previous(settingName);\n                var newComponentName = value;\n                \n                this.unbindFromComponent(oldComponentName, fn, fnContext);\n                this.bindToComponent(newComponentName, fn, fnContext);\n            }, this);\n            \n            var initialComponentName = this.settings.get(settingName);\n            this.bindToComponent(initialComponentName, fn, fnContext);\n        },\n\n        bindToComponent: function(id, fn, fnContext) {\n            // Abort if required parameters are missing\n            if (!id || !fn) {\n                return this;\n            }\n            \n            // We register on the \"change:{id}\" event\n            this.listenTo(mvc.Components, \"change:\" + id, fn, fnContext);\n\n            // However, it could be that the component already exists,\n            // in which case, we will invoke the callback manually\n            if (mvc.Components.has(id)) {\n                var ctx = mvc.Components.get(id);\n                _.defer(_.bind(function() {\n                    if (!this._removed) {\n                        fn.apply(fnContext, [mvc.Components, ctx, {}]);\n                    }\n                }, this));\n            }\n            \n            return this;\n        },\n\n        unbindFromComponent: function(id, fn, fnContext) {\n            // A component id is required\n            if (!id) {\n                return this;\n            }\n            \n            // We register on the \"change:{id}\" event\n            mvc.Components.off(\"change:\" + id, fn, fnContext);\n            \n            return this;\n        }\n    });\n\n    _.extend(BaseSplunkView.prototype, viewloggingmixin);\n    \n    return BaseSplunkView;\n});\n/**\n * Click event.\n *\n * @event\n * @name splunkjs.mvc.TableView#click\n * @property {Boolean} click:row - Fired when a row is clicked.\n * @property {Boolean} click:chart - Fired when a cell is clicked.\n */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/SplunkWebCore/search_mrsparkle/exposed/js/splunkjs/mvc/basesplunkview.js\n// module id = splunkjs/mvc/basesplunkview\n// module chunks = 3","define(function(require, exports, module) {\n    var TokenAwareModel = require('./tokenawaremodel');\n\n    /**\n     * @constructor\n     * @memberOf splunkjs.mvc\n     * @name Settings\n     * @description The **Settings** base input class contains the Settings model\n     * for SplunkJS components.\n     * @extends splunkjs.mvc.TokenAwareModel\n    */\n    var Settings = TokenAwareModel.extend(/** @lends splunkjs.mvc.Settings.prototype */{\n        sync: function() { return false; }\n    });\n    \n    return Settings;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/SplunkWebCore/search_mrsparkle/exposed/js/splunkjs/mvc/settings.js\n// module id = splunkjs/mvc/settings\n// module chunks = 3","\ndefine([\n            'underscore',\n            'backbone',\n            'splunk.logger',\n            'splunk.util'\n        ],\n        function(\n            _,\n            Backbone,\n            SplunkLogger,\n            splunkUtils\n        ) {\n\n    var logMode = splunkUtils.getConfigValue(\"JS_LOGGER_MODE\", \"None\"),\n        logLevel = splunkUtils.getConfigValue(\"JS_LOGGER_LEVEL\", \"INFO\"),\n        shouldAttachLogging = (logMode !== 'None' && logLevel === 'DEBUG'),\n        // don't attach loggers to events that will be very chatty\n        domEventBlacklist = ['mousemove', 'scroll'],\n        logger = null;\n\n    /**\n     * \n     * Mixin to add logging to a Backbone View\n     *\n     * This mixin will add logging statements to each DOM event handler in the view's \"events\" hash,\n     * but only if logging is enabled and the log level is DEBUG.\n     *\n     * In the case where logging should not be added this code is designed to do as little work as possible.  Attaching\n     * logging should not cause any changes in behavior.\n     *\n     * Usage:\n     *\n     *     var MyView = Backbone.View.extend({\n     *         // view code here\n     *     });\n     *     _.extend(MyView.prototype, viewloggingmixin);\n     * \n     * @mixin viewlogging\n     */\n    var viewlogging = {\n\n        /**\n         * An override of delegateEvents, which will wrap each event handler in a new function that \n         * will log a useful message and then invoke the original handler\n         * @param  {Object} events\n         *\n         * @memberOf viewlogging\n         */\n        delegateEvents: function(events) {\n            // if logging should not be attached, this should be an effective no-op\n            if(!shouldAttachLogging) {\n                return Backbone.View.prototype.delegateEvents.call(this, events);\n            }\n            events = events || _.result(this, 'events');\n            // if there are no events declared, again fall through to the Backbone implementation\n            if(!events) {\n                return Backbone.View.prototype.delegateEvents.call(this, events);\n            }\n            var wrappedEvents = {};\n            // loop over each eventName-handler pair, making sure to normalize the fact that the handler could be a\n            // function or the string name of an instance member, replace the handler with a wrapper function\n            // and call the Backbone implementation with the wrapped version of the handlers\n            _(events).each(function(handler, eventName) {\n                var normalizedHandler = _.isFunction(handler) ? handler : this[handler];\n                if(_.isFunction(normalizedHandler) && _(domEventBlacklist).indexOf(eventName) === -1) {\n                    var viewId = this.moduleId + '/' + this.cid;\n                    wrappedEvents[eventName] = function() {\n                        if(!logger) {\n                            logger = SplunkLogger.getLogger('viewlogging.js');\n                        }\n                        logger.debug('view ' + viewId + ' is handling event ' + eventName.replace(/\\s+/g, ' '));\n                        // \"this\" here will be the context that Backbone uses to invoke the handler\n                        normalizedHandler.apply(this, arguments);\n                    };\n                }\n                // in the case where normalizedHandler is for some reason not a function, it is not safe to create the\n                // wrapper, but make sure to be non-destructive\n                else {\n                    wrappedEvents[eventName] = handler;\n                }\n            }, this);\n            return Backbone.View.prototype.delegateEvents.call(this, wrappedEvents);\n        }\n\n    };\n\n    return viewlogging;\n\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/SplunkWebCore/search_mrsparkle/exposed/js/mixins/viewlogging.js\n// module id = mixins/viewlogging\n// module chunks = 3"],"sourceRoot":""}